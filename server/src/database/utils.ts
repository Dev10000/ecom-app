import { QueryResult } from 'pg';
import DB from '../config/database';

export const colorLog = (status: string, info: string): void => {
    let color = '';

    if (status === 'success') color = '\x1b[32m%s\x1b[0m'; // green
    if (status === 'error') color = '\x1b[31m%s\x1b[0m'; // red
    // if (status === 'info') color = '\x1b[36m%s\x1b[0m'; // cyan

    console.log(color, info);
};

export const useDBSetup = (
    seed?: boolean,
): { runSetupQuery(tableName: string, queryString: string): Promise<unknown> } => {
    const runSetupQuery = async (tableName: string, queryString: string) => {
        try {
            const ret = await DB.query(queryString);
            colorLog('success', `√ Table "${tableName}" successfully ${seed ? 'seeded with data' : '(re)created'}.`);
            return ret;
        } catch (error) {
            colorLog(
                'error',
                `× Table "${tableName}" NOT ${seed ? 'seeded with data' : '(re)created'}. ${
                    error.message
                } \n Details: \n ${error.detail}`,
            );
            // console.log({ error });
            return error.stack;
        }
    };

    return { runSetupQuery };
};

export const removeFields = <T, K extends keyof T>(entity: T, props: K[]): Omit<T, K> => {
    // eslint-disable-next-line no-sequences
    return props.reduce((s, prop) => (delete s[prop], s), entity);
};

export const pascalToSnakeCase = (input: string): string => {
    return input
        .split(/(?=[A-Z])/)
        .join('_')
        .toLowerCase();
};

//* *SLUGIFY START* */
/**
 * Input parameters and types
 * @param query Query string
 * @param values Array of values for the query
 */
// DBQUERY function - is used for all the queries in slugify. Returns either success or error response object
async function dbQuery(query: string, values: (string | number)[]): Promise<QueryResult | ErrorEvent> {
    // async/await
    try {
        const response = await DB.query(query, values);
        return response.rows[0];
    } catch (err) {
        throw new Error(err);
    }
}

/**
 * Input parameters and types
 * @param title User input string to be inserted into the column1
 * @param parent_id User input Parent Id of the category
 * @param slug Autogenretated slug
 * @param selectQuery Select query needs to include correct query string inlduing correct table and column1. column2 "slug" not needed as the check is done on title
 */
// Checks if the parent_id and the title unique constrain exist in the table
// and generates incrementing postfix number until not exist (title-1, title-2...)
// WHILE LOOP function
async function postfixLoop(
    title: string,
    parent_id: number,
    slug: string,
    selectQuery: string,
): Promise<Array<string>> {
    let selectValues: (string | number)[] = [title, parent_id];
    let newTitleSlug: string[];
    let i = 1;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        i += 1;
        const newTitle = `${title}-${i}`;
        selectValues = [newTitle, parent_id];

        // eslint-disable-next-line no-await-in-loop
        const response = await dbQuery(selectQuery, selectValues);

        if (!response) {
            slug = `${slug}-${i}`;
            title = `${title}-${i}`;
            newTitleSlug = [title, slug];
            break;
        }
    }
    return newTitleSlug;
}

/**
 * Input parameters and types
 * @param title User input string to be inserted into the column1
 * @param parent_id User input Parent Id of the category
 * @param column1 1st column name for the user input string usually "title"
 * @param column2 2nd column name for the autogenerated slug usually "slug"
 * @param table The name of the table to be inserted
 */
// MAIN SLUGIFY function
export const slugify = async (
    title: string,
    parent_id: number,
    column1: string,
    column2: string,
    table?: string,
): Promise<QueryResult | ErrorEvent> => {
    // Slugify the string
    let slug = title
        .normalize('NFD') // normalize()ing to NFD Unicode normal form decomposes combined graphemes into the combination of simple ones. The è of Crème ends up expressed as e +  ̀.
        .replace(/[\u0300-\u036f]/g, '') // Using a regex character class to match the U+0300 → U+036F range, it is now trivial to globally get rid of the diacritics, which the Unicode standard conveniently groups as the Combining Diacritical Marks Unicode block.
        .toLowerCase()
        .replace(/\s+/g, '-') // Replace spaces with -
        .replace(/[^\w-]+/g, '') // Removes anything not alphanumeric
        .replace(/\-\-+/g, '-'); // Replace multiple - with single -

    // First Select query - column2 "slug" not needed as the check is done on title
    const selectValues: (string | number)[] = [title, parent_id];
    const selectQuery = `SELECT ${column1} FROM ${table} WHERE ${column1} = $1 AND parent_id = $2`;
    const response = await dbQuery(selectQuery, selectValues);

    // Checks if parent_id and title unique constrain exist in the table and calls an postfixLoop() funtion if already exist.
    // postfixLoop generates the postfix number for the title and and the slug.
    if (response) {
        [title, slug] = await postfixLoop(title, parent_id, slug, selectQuery);
    }

    // Final Insert query into table
    const insertValues = [parent_id, title, slug];
    const insertQuery = `INSERT INTO ${table}(${column1}, parent_id, ${column2}) VALUES($2, $1, $3) RETURNING *`;
    const insertRes = await dbQuery(insertQuery, insertValues);

    return insertRes;
};
//* *SLUGIFY END* */
